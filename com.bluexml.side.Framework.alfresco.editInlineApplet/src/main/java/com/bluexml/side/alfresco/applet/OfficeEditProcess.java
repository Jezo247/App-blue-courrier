package com.bluexml.side.alfresco.applet;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;

import com.bluexml.side.alfresco.applet.ApplicationHelper.ApplicationExe;


public class OfficeEditProcess extends EditProcess {
	
	static final String TMP_DIR = System.getProperty("java.io.tmpdir");
	private static final long WATCH_FREQUENCY_MS = 1000;
	
	private final String fullExecutablePath;
	
	public static OfficeEditProcess createFromMimetype(File file, String mimetype) {
		
		if (null == mimetype || mimetype.isEmpty()) {
			throw new IllegalArgumentException("The provided mimetype has to be a valid string");
		}
		
		final ApplicationExe applicationExe = ApplicationHelper.getApplicationExecutable(mimetype);
		if (null == applicationExe) {
			throw new IllegalStateException(String.format("Cannot find a valid executable for mimetype '%s'", mimetype));
		}
		
		return new OfficeEditProcess(file, applicationExe);
		
	}
	
	private OfficeEditProcess(File file, ApplicationExe applicationExe) {
		
		super(file);
		
		fullExecutablePath = ApplicationHelper.getApplicationFullPath(applicationExe);
		if (null == fullExecutablePath) {
			throw new IllegalStateException(String.format("Cannot find a valid executable for '%s'", applicationExe));
		}
		
	}
	
	protected void launch() throws IOException {
		
		final boolean alreadyLaunched = isExecutableRunning();
		
	    final String[] command = { fullExecutablePath, editedFile.getCanonicalPath() };
		final ProcessBuilder p = new ProcessBuilder(command);
	    p.redirectErrorStream(true);
	    final Process process = p.start();
	
	    if (!alreadyLaunched) {
	    	try {
	    		process.waitFor();
	    	} catch (InterruptedException e) {
	    		// ignore
	    	}
	    } else {
	    	watchInstance();
	    }
		
	}	
	
	/**
	 * Check the Windows task-list to verify whether there is still an instance
	 * of Word running
	 * 
	 * @return true if an instance can be found
	 * @throws IOException
	 */
	private boolean isExecutableRunning() throws IOException {
		
        final String[] command = { "tasklist.exe", "/fi", "\"imagename eq " + fullExecutablePath + "\"" };
		final ProcessBuilder tasklist = new ProcessBuilder(command);
        final Process test = tasklist.start();
        
        BufferedReader input = null;
        try {
        	input = new BufferedReader(new InputStreamReader(test.getInputStream()));
        	
        	String line;
            if ((line = input.readLine()) != null) {
                if (line.isEmpty()) return true;
            }
        }
        finally {
        	try {
        		if (null != input) input.close();
        	} 
        	catch (IOException e) {
        		// ignore
        	}
        	finally {
        		input = null;
        	}
        }        
	
        return false;
	}

	/**
	 * Check the instance is still running by watching the "locked" file
	 */
	private void watchInstance() {
		
		final File lockedFile = getLockedFile();
		if (null == lockedFile) {
			final String message = String.format("The working file derived from file '%s' cannot be found as expected!", editedFile.getName());
			throw new IllegalStateException(message);
		}
		
		final Watcher<Void> watcher = new Watcher<Void>(WATCH_FREQUENCY_MS) {
			@Override
			protected boolean checkCondition() {
				return !lockedFile.exists();
			}
		};
		watcher.blockSafeUntilTrue();
		
	}
	
	/**
	 * Returns the temporary file normally generated by Microsoft Word during
	 * editing
	 * <p>
	 * Abort the operation if not found within 2s.
	 * 
	 * @return the "locked" file if it can be found, else null
	 */
	private File getLockedFile() {

		final Watcher<File> watcher = new Watcher<File>(500, 2000) {
			
			File lockedFile;
			
			@Override
			protected boolean checkCondition() {
				
				final File parentDirectory = editedFile.getParentFile();
				final String editedFileName = editedFile.getName();
				
				final String ownerFileName = "~$" + editedFileName.substring(2);
				lockedFile = new File(parentDirectory, ownerFileName); // owner file
				if (lockedFile.exists()) return true;
				
				final String lockFileName = ".~lock." + editedFileName;
				lockedFile = new File(parentDirectory, lockFileName);
				if (lockedFile.exists()) return true;
				
				lockedFile = null;
				return false;
				
			}
			
			@Override
			protected File getResult() {
				return lockedFile;
			}
			
		};
		return watcher.blockSafeUntilTrue();		
		
	}
}
